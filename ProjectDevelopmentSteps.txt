Proje içerisinde bazý adýmlarý arayabilirsiniz. Örn. (ProjectDevelopment.txt step 9.10).

Section 1

1. Her servisi daha kolay anlaþýlabilir olmasý adýna klasörlere bölüyoruz.
1.1 Oluþturduðumuz servis klasörünün içerisine yeni bir ASP.NET Core Web API projesi oluþturuyoruz. Cross platform olarak seçmeyi unutma!
1.2 Oluþturduðumuz projenin içindeki Properties klasörünün içinde launchSettings.json dokumanýnda port deðiþikliðini yapýyor ve açýlýþ þeklini deðiþtiriyoruz.
1.3 Oluþturduðumuz projede Dependencies kýsmýna sað týklayarak NuGet ile MongoDB.Driver yükleme iþlemini yapýyoruz.
1.4 Oluþturduðumuz projede Model isminde bir klasör yaratýyoruz. Bu dosyanýn içerisine Collection`larýmýza/Table denk gelecek olan modelleri oluþturuyoruz.
2. Solution içerisine yeni bir Shared isminde klasör oluþturulur.
2.1 Ýçerisinde Class Library oluþturulur. Oluþturma esnasýnda framework olarak Identity server 3.1 olacaðýndan dolayý þimdilik bu þekilde seçiyoruz. Ýleride NuGet paketi ile 5.0 a geçmekte mümkün.
2.2 Oluþturduðumuz Class Library içerisine Response.cs isminde bir response verileri içerecek sýnýf oluþturulur.
2.3 Oluþturduðumuz Class Library içerisine null response dönebilmek için NoContent.cs isminde bir sýnýf oluþturulur.
3. Catalog projemizde Dtos adýnda bir klasör oluþturuyoruz.
3.1 Her bir modelimiz için bir DTO sýnýfý oluþturmakla beraber CU(Create/Update) iþlemleri için de DTO sýnýflarý oluþturuyoruz.
4. Bu aþamaya geldiðimizde servisimize bir AutoMapper ekliyor olacaðýz. NuGet manager ile ASP.NET Core AutoMapper`ý projemize Dependencies kýsmýndan dahil etmemiz gerekmektedir.
4.1 Yükleme iþleminin ardýndan projemizin Startup.cs dosyasýnda ayarlarýný yapmayý unutmamalýyýz.
4.2 Projemizin içerisinde Mapping isminde bir klasör oluþturuyarak içerisinde GeneralMapping.cs isminde bir sýnýf oluþturuyoruz.
5. Veritabaný ayarlarýný ve genel proje ayarlarýný içerisinde barýndýrabileceðimiz appsetting.json dosyasýný ele alabiriz. Örn. Collection/Table isimleri, baðlantý adresi, DB ismi vs.
5.1 Belirteceðim bu ayarlarý bir class üzerinden okuyabilmek için ilk oluþturduðumuz proje içerisinde Settings adýnda bir klasör oluþturuyoruz.
5.2 Okuyacaðýmýz ayarlarý bir interface ile soyutlayýp daha sonra bu soyutlamayý kullanacaðýmýz sýnýflarýmýzý projemize dahil ediyoruz (IDatabaseSettings ve DatabaseSettings).
6. Servis methodlarýmýzý oluþturmak için projenin altýnda Services isminde bir klasör oluþturuyoruz.
6.1 Her bir modelimize ait servis sýnýflarýný Services altýnda oluþturuyoruz ve bir Interface`ten implement edilmelerini saðlýyoruz.
6.2 Constructor metodunda veritabaný baðlantýsý iþlemleri ve collection/table belirteçlerini ekliyoruz.
6.3 Shared altýnda Response.cs sýnýfýný kullanabilmek için projeye dahil etmemiz gerekiyor.
6.4 Oluþturma iþlemleri bittiðinde Startup.cs dosyasýnda yeni bir scope tanýmý yapýyoruz. Örn. services.AddScoped<ICategoryService, CategoryService>();
7. Servislerimizi oluþturduktan sonra sýra endpointlerimizi belirleyeceðimiz kýsýma geldi.
7.1 Projemizde Controller isminde bir klasör oluþturuyoruz.
7.2 Controller klasörüne sað týklayarak Add > Controlller seçeneðini seçiyoruz.
7.3 Karþýmýza çýkan pencereden sol tarafta API seçili olduðuna ve bir empty controller eklediðimizden emin oluyoruz.
7.4 Bu aþamada ayrý bir parantez açacaðýz. Genel bir response sýnýfý oluþturarak kontrol mekanizmasý eforunu azaltýyor olacaðýz.
7.4.1 Daha önceden oluþturduðumuz Shared klasöründe ControllerBases isimli bir klasör oluþturuyoruz.
7.4.2 Oluþturudðumuz bu klasörün içerisine CustomControllerBase.cs isminde bir sýnýf oluþturuyoruz.
7.4.3 Oluþturduðumuz sýnýf ControllerBase`ten türemeli fakat bu noktada projemize referans olarak eklememiz gereken bir taným gerekmektedir.
7.4.4 Bu tanýmý yapabilmek için Shared altýnda oluþturduðumuz projeye sað týklayarak Edit Project File seçeneðini týklýyoruz. Ardýndan ilgili içerikte iþaretlenmiþ kod bloðunu ekliyoruz.
7.5 Oluþturduðumuz controller sýnýfýnda ilgili endpointlerin geliþtirmelerini yapýyoruz.

Section 2 Docker ve Container`lar

1. Docker kurulumu yapýlýr.
2. Portainer docker ile ayaða kaldýrýlýr.
3. Portainer ile App Templates kýsmýndan MongoDB container`ý ayaða kaldýrýlýr.

Section 3 Identity Server Kurulum

1. https://github.com/IdentityServer/IdentityServer4.Templates adresine eriþilir.
2. dotnet new -i identityserver4.templates komutu power shell`de çalýþtýrýlýr.
3. Solution dosyamýza locate olarak içerisinde IdentityServer isminde bir klasör oluþturuyoruz.
3.1 Locate olduðumuz dosyada dotnet new is4aspid --name XProject.IdentityServer komutu power shell`de çalýþtýrýlýr.
3.2 IDE`mizde ana solution altýnda IdentityServer klasörü oluþturulur ve sað týklayarak var olan bir projeyi ekle seçeneðinden kurulumunu yaptýðýmýz IdentityServer projesi seçilir.
4. Portainer`a baðlanarak SQL Server (Linux) container`ýný kuruyoruz.
4.1 SQL server image bulamýyor ve kuramýyorsa manuel olarak bir image edinip bunu Docker`da run ediyoruz.
5. Projemize dahil ettiðimiz IdentityServer projesinde Data altýnda bulunan Migrations klasörünü siliyoruz.
6. appsettings.json dosyasýnda veritabaný baðlantý bilgilerimizi tanýmlýyoruz.
7. Startup.cs içerisinde DbContext bilgileri bölümünde default olarak Sqlite tanýmý bulunmaktadýr. SqlServer için deðiþiklik yapmamýz gerekmektedir.
7.1 IdentityServer projemizin dependency kýsmýnda NuGet ile Microsoft.EntityFrameworkCore.SqlServer paketini indiriyoruz (IdentityServer projesi 3.1.5 versiyonunda olduðundan bizde yüklerken bunu seçmeliyiz).
8. Migration iþlemimiz için Program.cs dosyasýna gidiyoruz ve default seed ile ilgili kýsýmlarý comment out yapýyoruz. Ardýndan veritabanýmýz yok ise oluþturmasý için kodlarýmýzý yazýyoruz.
8.1 Eðer kullanýcýmýzýn IdentityServer sutunlarý haricinde kendimize ait sutunlarý da saklamak istiyorsak Models altýnda bulunan ApplicationUser.cs dosyasýnda property olarak tanýmlamamýz mümkündür.
8.2 Kodumuzu yazdýktan sonra üst kýsýmdan projemizi IdentityServer çalýþtýracak þekilde ayarlýyoruz, Package Manager Console`da ayný þekilde ayarlýyoruz. Eðer console kýsmý görünmüyorsa Tools > Nuget Package Manger > Nuget Package Manger Console týklayarak görünmesini saðlýyoruz.
8.3 Package Manager Console kýsmýnda add-migration initial komutunu çalýþtýrýyoruz.
8.4 update-database komutunu çalýþtýrýyoruz. Projeyi çalýþtýrdýðýmýzda kullanýcýmýzý otomatik oluþturuyor olacak.
8.5 Identity server endpointlerini inceleyebilmek için https://identityserver4.readthedocs.io/en/latest/endpoints/discovery.html adresinde istek atabilir veya kendi url`imiz üzerinden görebiliriz.
9. IdentityServer projemizde Dtos adýnda bir klasör oluþturuyoruz.
9.1 Dtos içerisinde SignUpDto.cs adýnda bir sýnýf oluþturuyoruz ve kayýt iþleminde tutmak istediðimiz property`leri belirliyoruz.
9.2 IdentityServer projemizde Controller adýnda bir klasör oluþturuyoruz.
9.3 Oluþturduðumuz controller içierisine UserController.cs adýnda bir controller oluþturuyoruz.
9.4 Entpoint`lere istek atýldýktan sonra cevaplarý belli bir standartta dönmemiz için daha önceden hazýrlamýþ olduðumuz Response.cs sýnýfýný kullanacaðýz.
9.5 Bu sýnýf diðer projemizin Shared klasöründe olduðundan dolayý IdentityServer Dependencies kýsmýna sað týklayarak Add Project Reference bölümünden projemize dahil ediyoruz.
9.6 Endpoint`lerimize istek yapýlýrken hangisinin user token ile hangisinin public tokenlar ile iþlem yapabildiðini ayýrt etmek için IdentityServer içerisinde Config.cs sýnýfýnda tanýmlar yapmamýz gerekiyor.
9.7 Kullanýcý bilgisi içermeyen fakat client id bilgisinin bulunduðu scope(kýsým) tanýmlanýr. Endpoint`te özel read, write, delete, full iþlem gibi izinler tanýmlanabilir.
9.8 Oluþturduðumuz izinlerin Aud belirteci ile atanmasý saðlanýr.
9.9 Ýzinlerini belirlemiþ olduðumuz API`lere istek yapabilecek client bilgisini tanýmlýyoruz. GrantType bilgisinin GrantTypes.ClientCredentials olmasý gerekmektedir.
9.10 Belirlediðimiz bu izin bilgilerini, client tanýmlarýný Startup.cs içerisinde memory`de saklamak üzere tanýmlýyoruz.
9.10.1 https://localhost:5001/connect/token endpoint`imize body içerisinde client_id:WebMvcClient client_secret:secret grant_type:client_credentials parametreleri ile istek yapýyoruz.
9.11 Startup.cs sýnýfýmýzda local bazýnda deðerlendirdiðimiz endpointlerimiz için tanýmýmýzý ekliyoruz.
9.11.1 Startup.cs sýnýfýmýzda authentication uygulanacaðý bilgisini tanýmlýyoruz.
9.11.2 Client token bekleyeceðimiz endpoint`imiz için koruma etiketi tanýmlýyoruz.
9.11.3 Controller içierisinde bulunan methodlarýmýza ulaþýmý ayarlamak için attribute tanýmýmýzý yapýyoruz.
9.12 SignUp endpointini test etmek için postmanden https://localhost:5001/api/user/signup adresini giriyoruz ve token alma adresimizden bir token ediniyoruz. Daha sonra edindiðimiz bu token`i Authorization kýsmýnda Type OAuth 2.0 seçerek tokenizimizi ilgili alana yazýyoruz ve istek atýyoruz.
10. Daha önceden oluþturduðumuz Catalog projemizin endpointlerini koruma altýna almak için öncelikle dependency olarak JwtBearer`ý projemize dahil ediyoruz.
11. Bu aþamada token daðýtýmýný kimin yaptýðýný belirtmek için tanýmlamalar yapmamýz gerekmektedir.
11.1 appSettings.json içerisinde IdentityServer url bilgisini IdentityServerURL attribute olarak tanýmlýyoruz.
11.2 Tanýmlamýþ olduðumuz bu bilgiyi Startup.cs içerisinde Authority propertisine eþitliyoruz.
11.3 Audience tanýmlamamýzý yapýyoruz.
11.4 Http/Https meta bilgisi ile çalýþma durumunu tanýmlýyoruz.
11.5 Configurasyonumuza Authentication kullanýlacaðý bilgisini tanýmlýyoruz.
12. Oluþturduðumuz her iki projenin ayný anda çalýþabilmesi için Solution üzerinde sað týklayarak Set Startup Project seçeneðini seçiyoruz.
12. Karþýmýza gelen ekranda Multiple startup project seçeneðinden ilgili projeleri Start olarak seçiyoruz.
13. Projemize ekleyeceðimiz tüm endpoint`ler için her sýnýfa Authorize annotation eklemek yerine Startup.cs içerisinde tanýmlýyoruz.
14. User token based yani grant type validation için akýþta devam eden adýmlar uygulanýr.
14.1 Validasyon iþlemi için IdentityServer projemizin içerisinde Server adýnda bir klasör oluþturuyoruz.
14.2 Oluþturduðumuz bu klasörün içererisine IdentityResourceOwnerPasswordValidator.cs adýnda bir sýnýf oluþturuyoruz ve IResourceOwnerPasswordValidator interface`ini implemente ettiðinden emin oluyoruz.
14.3 Oluþturduðumuz bu sýnýfda dilersek kendi authentiocation kodumuzu da geliþtirebilirz fakat hazýr yapý ile saðlanan geliþtirme iþimizi hallediyor.
14.4 Dilersek kendi hata mesajýmýzý da mevcut dönecek hata mesajýna iliþtirebiliyoruz.
14.5 Kontroller saðlandýðýnda sýnýfýmýzýn geri döneceði bilginin resource owner grant type credential workflow tipinde olmasý gerekmetedir. Böylece token dönüþü saðlayabilir olacaktýr.
15.6 Bu iþlemlerinden ardýndan Startup.cs içerisinde builder`ýmýza IdentityResourceOwnerPasswordValidator.cs bilgisini geçiyoruz.
16. Sýradaki aþamamýz IdentityResource bilgisini hangi veriler ile dolduracaðýmýz bulunmaktadýr. Bu iþlemi IdentityServer projemizin Config.cs sýnýfýnda gerçekleþtireceðiz.
16.1 IdentityResources scope`unda token içerisinde göstereceðimiz bilgileri tanýmlýyororuz. OpenId bilgisi mutlaka tanýmlý olmalýdýr.
16.2 Ardýndan token ile iþleme devam edebilecek bir client tanýmlamasý yapýyoruz. Bu client içerisinde hangi bilgileri ileteceðimizi, access token geçerlilik süresini, refresh token geçerlilik süresini ve refresh token bilgisinin kaç kez kullanýlabileceðini tanýmlýyoruz.

